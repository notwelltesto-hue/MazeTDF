<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Maze TD - Chunk-Based Infinite World</title>
  <style>
    body { background:#111; color:#ddd; font-family: sans-serif; display:flex; flex-direction:column; align-items:center; padding:12px; margin: 0; overflow: hidden; }
    canvas { background:#000; image-rendering: crisp-edges; border:4px solid #222; }
    .info { margin-top:8px; }
    .hint { color:#aaa; font-size:13px; }
  </style>
</head>
<body>
  <h2 style="color:white">Maze Tower Defense â€” Chunk-Based Infinite World</h2>
  <canvas id="game"></canvas>
  <div class="info">
    <div id="hud"></div>
    <div class="hint">Keys: 1=Basic, 2=Lighter, 3=Mine, R=random seed. WASD to move, Q/E to zoom.</div>
  </div>

<script>
(() => {
  // ---------- Config ----------
  const TILE_SIZE = 32;
  const CHUNK_SIZE = 16;
  let CANVAS_W = window.innerWidth - 30;
  let CANVAS_H = window.innerHeight - 150;
  const spawnIntervalMs = 1700;

  const COST = { basic: 20, lighter: 30, mine: 50 };
  const TOWER = { BASIC: 'basic', LIGHTER: 'lighter', MINE: 'mine' };
  let selectedTower = TOWER.BASIC;

  const canvas = document.getElementById('game');
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;
  const ctx = canvas.getContext('2d');

  let gems, lives, chunks, towers, enemies, projectiles, spawnPoints, base;
  let lastSpawn = 0;

  const camera = { x: 0, y: 0, zoom: 1, speed: 400 };
  const keys = {};

  // --- RNG & Seed ---
  function mulberry32(a) {
    return function() {
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = t + Math.imul(t ^ (t >>> 7), 61 | t) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function parseSeed() {
    const params = new URLSearchParams(location.search);
    const p = params.get('seed');
    return p ? Number(p) || 0 : Math.floor(Math.random()*0x7fffffff);
  }

  let GAME_SEED = parseSeed();
  let rng = mulberry32(GAME_SEED);

  function setSeed(newSeed) {
    GAME_SEED = newSeed | 0;
    rng = mulberry32(GAME_SEED);
    initGame(true);
  }

  // ---------- Chunk System ----------
  function worldToChunkCoords(worldX, worldY) {
    const cx = Math.floor(worldX / CHUNK_SIZE);
    const cy = Math.floor(worldY / CHUNK_SIZE);
    const lx = worldX - cx * CHUNK_SIZE;
    const ly = worldY - cy * CHUNK_SIZE;
    return { cx, cy, lx, ly };
  }

  function getChunk(cx, cy) {
    const key = `${cx},${cy}`;
    if (!chunks.has(key)) {
      chunks.set(key, generateChunk(cx, cy));
    }
    return chunks.get(key);
  }

    function deterministicTile(x, y) {
        const h = (GAME_SEED ^ (x * 374761393) ^ (y * 668265263)) >>> 0;
        const cellRng = mulberry32(h);
        const isWall = cellRng() < 0.28;
        const hasGem = cellRng() < 0.12;
        return { tile: isWall ? 1 : 0, gem: !isWall && hasGem };
    }

  function generateChunk(cx, cy) {
    const chunk = {
      tiles: Array.from({ length: CHUNK_SIZE }, () => Array(CHUNK_SIZE)),
      fog: Array.from({ length: CHUNK_SIZE }, () => Array(CHUNK_SIZE).fill(true)),
      gemNodes: Array.from({ length: CHUNK_SIZE }, () => Array(CHUNK_SIZE)),
    };
    const worldStartX = cx * CHUNK_SIZE;
    const worldStartY = cy * CHUNK_SIZE;
    for (let ly = 0; ly < CHUNK_SIZE; ly++) {
      for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        const det = deterministicTile(worldStartX + lx, worldStartY + ly);
        chunk.tiles[ly][lx] = det.tile;
        chunk.gemNodes[ly][lx] = det.gem;
      }
    }
    return chunk;
  }

  function getTile(worldX, worldY) {
    const { cx, cy, lx, ly } = worldToChunkCoords(worldX, worldY);
    const chunk = getChunk(cx, cy);
    return {
      tile: chunk.tiles[ly][lx],
      isFoggy: chunk.fog[ly][lx],
      hasGemNode: chunk.gemNodes[ly][lx]
    };
  }

  function setFog(worldX, worldY, isFoggy) {
      const { cx, cy, lx, ly } = worldToChunkCoords(worldX, worldY);
      const chunk = getChunk(cx, cy);
      chunk.fog[ly][ly] = isFoggy;
  }


  // ---------- Game Logic ----------
  function revealArea(worldX, worldY, radius) {
    const tilesToUpdate = new Set();
    for (let y = worldY - radius; y <= worldY + radius; y++) {
      for (let x = worldX - radius; x <= worldX + radius; x++) {
        if (Math.hypot(x - worldX, y - worldY) <= radius) {
            const { cx, cy, lx, ly } = worldToChunkCoords(x, y);
            const chunk = getChunk(cx, cy);
            if (chunk.fog[ly][lx]) {
                chunk.fog[ly][lx] = false;
                // If we revealed a path tile on the edge of darkness, check for spawner
                if(chunk.tiles[ly][lx] === 0) {
                    scanForNewSpawner(x,y);
                }
            }
        }
      }
    }
    for (const e of enemies) recomputeEnemyPath(e);
  }

  function scanForNewSpawner(x, y) {
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      let isEdgeOfDarkness = false;
      for(const d of dirs) {
          if(getTile(x + d[0], y + d[1]).isFoggy) {
              isEdgeOfDarkness = true;
              break;
          }
      }
      if(!isEdgeOfDarkness) return;

      const minSpawnDist = 10;
      for (const sp of spawnPoints) {
          if (Math.hypot(sp.x - x, sp.y - y) < minSpawnDist) return;
      }

      if (findPath({x,y}, base)) {
          spawnPoints.push({x,y});
      }
  }

  function findPath(start, goal) {
    const q = [{x:start.x,y:start.y}];
    const visited = new Set([`${start.x},${start.y}`]);
    const prev = new Map();
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while (q.length) {
      const cur = q.shift();
      if (cur.x === goal.x && cur.y === goal.y) {
        const path = [];
        let p = cur;
        while (p) {
          path.unshift(p);
          p = prev.get(`${p.x},${p.y}`);
        }
        return path;
      }
      for (const d of dirs) {
        const nx = cur.x + d[0], ny = cur.y + d[1];
        const key = `${nx},${ny}`;
        if (!visited.has(key) && getTile(nx, ny).tile === 0) {
          visited.add(key);
          prev.set(key, cur);
          q.push({x:nx,y:ny});
        }
      }
    }
    return null;
  }

  function canPlaceTower(x,y,type) {
    const tile = getTile(x,y);
    if (tile.isFoggy || tile.tile === 1) return false;
    if (towers.some(t => t.x===x && t.y===y)) return false;
    if (type === TOWER.MINE && !tile.hasGemNode) return false;
    if (spawnPoints.some(sp => sp.x===x && sp.y===y)) return false;
    if (x === base.x && y === base.y) return false;
    return true;
  }

  function placeTower(x,y,type) {
    if (!canPlaceTower(x,y,type)) return;
    const cost = COST[type];
    if (gems < cost) return;
    gems -= cost;
    towers.push({ x, y, type, cooldown: 0, fireRate: type===TOWER.BASIC ? 0.6 : 2.0, range: type===TOWER.BASIC ? 3.2 : 0, angle: 0, mineTimer: 0 });
    if (type === TOWER.LIGHTER) {
      revealArea(x,y,5);
    }
  }

  function spawnEnemy() {
    if (spawnPoints.length === 0) return;
    const spawnPoint = spawnPoints[Math.floor(rng() * spawnPoints.length)];
    const path = findPath(spawnPoint, base);
    if (!path) return;
    const maxHp = 20 + Math.floor(rng()*20) + Math.floor(lastFrameTime/30000);
    enemies.push({ path, idx: 0, x: path[0].x + 0.5, y: path[0].y + 0.5, speed: 1.2 + rng() * 0.6, hp: maxHp, maxHp });
  }

  function recomputeEnemyPath(e) {
    const sx = Math.floor(e.x), sy = Math.floor(e.y);
    const p = findPath({x:sx,y:sy}, base);
    if (p) {
      e.path = p;
      e.idx = 0;
    }
  }

  function updateEnemies(dt) {
    for (let i = enemies.length-1; i>=0; i--) {
      const e = enemies[i];
      if (!e.path || e.idx >= e.path.length - 1) {
        if(e.path) lives -= 1;
        enemies.splice(i,1);
        continue;
      }
      const target = e.path[e.idx+1];
      const tx = target.x + 0.5, ty = target.y + 0.5;
      const dx = tx - e.x, dy = ty - e.y;
      const dist = Math.hypot(dx,dy);
      const move = e.speed * dt;
      if (dist <= move) {
        e.x = tx; e.y = ty; e.idx++;
      } else {
        e.x += (dx/dist) * move;
        e.y += (dy/dist) * move;
      }
    }
  }

  function updateTowers(dt) {
    for (const t of towers) {
      if (t.type === TOWER.BASIC) {
        t.cooldown -= dt;
        let target = null, best = Infinity;
        for (const e of enemies) {
           const d = Math.hypot((t.x + 0.5) - e.x, (t.y + 0.5) - e.y);
          if (d <= t.range && d < best) { best = d; target = e; }
        }
        if (target) {
          const tx = target.x - (t.x + 0.5), ty = target.y - (t.y + 0.5);
          const desired = Math.atan2(ty, tx);
          const diff = normalizeAngle(desired - t.angle);
          const rotSpeed = 7.0 * dt;
          t.angle += Math.sign(diff) * Math.min(Math.abs(diff), rotSpeed);
          if (t.cooldown <= 0 && Math.abs(diff) < 0.1) {
            projectiles.push({ x: t.x + 0.5, y: t.y + 0.5, vx: Math.cos(t.angle) * 8.0, vy: Math.sin(t.angle) * 8.0, target: target, life: 1.2 });
            t.cooldown = t.fireRate;
          }
        } else {
          t.angle += 0.5 * dt;
        }
      } else if (t.type === TOWER.MINE) {
        t.mineTimer += dt;
        if (t.mineTimer >= 3.5) {
          gems += 10 + Math.floor(rng()*8);
          t.mineTimer = 0;
        }
      }
    }
    for (let i=enemies.length-1;i>=0;i--) {
      if (enemies[i].hp <= 0) {
        gems += 5 + Math.floor(rng()*5);
        enemies.splice(i,1);
      }
    }
  }

  function normalizeAngle(a) {
    while (a > Math.PI) a -= Math.PI*2;
    while (a < -Math.PI) a += Math.PI*2;
    return a;
  }

  function updateProjectiles(dt) {
    for (let i=projectiles.length-1;i>=0;i--) {
      const p = projectiles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.target?.hp > 0 && Math.hypot(p.x - p.target.x, p.y - p.target.y) < 0.5) {
        p.target.hp -= 7;
        projectiles.splice(i,1);
        continue;
      }
      if (p.life <= 0 || p.target?.hp <=0) projectiles.splice(i,1);
    }
  }

  // ---------- Rendering ----------
  function drawGrid() {
        const view = {
            x: camera.x, y: camera.y,
            w: CANVAS_W / camera.zoom, h: CANVAS_H / camera.zoom
        };
        const startX = Math.floor(view.x), endX = Math.ceil(view.x + view.w);
        const startY = Math.floor(view.y), endY = Math.ceil(view.y + view.h);
        
        const startCX = Math.floor(startX / CHUNK_SIZE);
        const endCX = Math.ceil(endX / CHUNK_SIZE);
        const startCY = Math.floor(startY / CHUNK_SIZE);
        const endCY = Math.ceil(endY / CHUNK_SIZE);

        for (let cy = startCY; cy < endCY; cy++) {
            for (let cx = startCX; cx < endCX; cx++) {
                const chunk = getChunk(cx, cy);
                const worldStartX = cx * CHUNK_SIZE;
                const worldStartY = cy * CHUNK_SIZE;
                for (let ly = 0; ly < CHUNK_SIZE; ly++) {
                    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
                        const px = worldStartX + lx, py = worldStartY + ly;
                        if(chunk.fog[ly][lx]) {
                            ctx.fillStyle = '#0c0c0c';
                        } else {
                            ctx.fillStyle = chunk.tiles[ly][lx] === 1 ? '#3a3a3a' : '#bdbdbd';
                        }
                        ctx.fillRect(px * TILE_SIZE, py * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                        if (!chunk.fog[ly][lx]) {
                            if(chunk.tiles[ly][lx] === 0) {
                                ctx.strokeStyle = '#a6a6a6';
                                ctx.strokeRect(px * TILE_SIZE, py * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            }
                            if (chunk.gemNodes[ly][lx]) {
                                ctx.fillStyle = '#8ff';
                                ctx.beginPath();
                                ctx.arc((px + 0.5) * TILE_SIZE, (py + 0.5) * TILE_SIZE, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                }
            }
        }
        ctx.fillStyle = '#444'; ctx.fillRect(base.x * TILE_SIZE, base.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = '#222'; ctx.fillRect(base.x * TILE_SIZE + 6, base.y * TILE_SIZE + 6, TILE_SIZE - 12, TILE_SIZE - 12);

        spawnPoints.forEach(sp => {
            ctx.fillStyle = 'rgba(150, 0, 0, 0.7)';
            ctx.fillRect(sp.x * TILE_SIZE, sp.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        });
    }

  function drawTowers() {
    for (const t of towers) {
      const cx = (t.x + 0.5) * TILE_SIZE, cy = (t.y + 0.5) * TILE_SIZE;
      if (t.type === TOWER.BASIC) {
        ctx.fillStyle = 'blue'; ctx.beginPath(); ctx.arc(cx,cy, TILE_SIZE*0.3, 0, Math.PI*2); ctx.fill();
        ctx.save(); ctx.translate(cx,cy); ctx.rotate(t.angle);
        ctx.fillStyle = '#0033cc'; ctx.fillRect(0, -5, TILE_SIZE*0.45, 10); ctx.restore();
      } else if (t.type === TOWER.LIGHTER) {
        ctx.fillStyle = 'gold'; ctx.beginPath(); ctx.arc(cx,cy, TILE_SIZE*0.3, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,230,100,0.1)'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(cx,cy, TILE_SIZE*5, 0, Math.PI*2); ctx.stroke(); ctx.lineWidth = 1;
      } else if (t.type === TOWER.MINE) {
        ctx.fillStyle = 'green'; ctx.beginPath(); ctx.arc(cx,cy, TILE_SIZE*0.28, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0a0'; ctx.fillRect(cx-6, cy+4, 12, 6);
      }
    }
  }

  function drawEnemies() {
    for (const e of enemies) {
      const cx = e.x * TILE_SIZE, cy = e.y * TILE_SIZE;
      ctx.fillStyle = 'crimson'; ctx.fillRect(cx - 10, cy - 10, 20, 20);
      const hpFrac = Math.max(0, e.hp) / e.maxHp;
      ctx.fillStyle = '#222'; ctx.fillRect(cx - 12, cy - 16, 24, 4);
      ctx.fillStyle = '#0f0'; ctx.fillRect(cx - 12, cy - 16, 24 * hpFrac, 4);
    }
  }

  function drawProjectiles() {
    ctx.fillStyle = 'yellow';
    for (const p of projectiles) {
      ctx.beginPath(); ctx.arc(p.x * TILE_SIZE, p.y * TILE_SIZE, 3, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawHUD() {
    document.getElementById('hud').innerHTML = `Seed: <b>${GAME_SEED}</b> &nbsp; Gems: <b>${gems}</b> &nbsp; Lives: <b>${lives}</b> &nbsp; Selected: <b>${selectedTower}</b> &nbsp; Spawners: ${spawnPoints.length}`;
  }

    function screenToWorld(x, y) {
        const worldX = x / camera.zoom + camera.x;
        const worldY = y / camera.zoom + camera.y;
        return { x: worldX, y: worldY };
    }

  // ---------- Input & Loop ----------
  canvas.addEventListener('click', (ev) => {
        const rect = canvas.getBoundingClientRect();
        const worldCoords = screenToWorld(ev.clientX - rect.left, ev.clientY - rect.top);
        placeTower(Math.floor(worldCoords.x), Math.floor(worldCoords.y), selectedTower);
    });

  document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === '1') selectedTower = TOWER.BASIC;
    else if (e.key === '2') selectedTower = TOWER.LIGHTER;
    else if (e.key === '3') selectedTower = TOWER.MINE;
    else if (e.key.toLowerCase() === 'r') setSeed(Math.floor(Math.random()*0x7fffffff));
  });

  document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

  let lastFrameTime = performance.now();
  function gameLoop(now) {
        const dt = Math.min(0.1, (now - lastFrameTime) / 1000);
        lastFrameTime = now;

        updateCamera(dt);
        
        lastSpawn += dt * 1000;
        if (lastSpawn >= spawnIntervalMs) {
            spawnEnemy();
            lastSpawn = 0;
        }

        updateEnemies(dt);
        updateTowers(dt);
        updateProjectiles(dt);

        ctx.save();
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x * TILE_SIZE, -camera.y * TILE_SIZE);
        
        drawGrid();
        drawTowers();
        drawEnemies();
        drawProjectiles();

        ctx.restore();
        drawHUD();

        if (lives <= 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            ctx.fillStyle = 'white'; ctx.font = '36px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText('Game Over', CANVAS_W / 2, CANVAS_H / 2);
        } else {
            requestAnimationFrame(gameLoop);
        }
    }

  function updateCamera(dt) {
    const moveSpeed = camera.speed * dt / camera.zoom;
    if (keys['w']) camera.y -= moveSpeed / TILE_SIZE;
    if (keys['s']) camera.y += moveSpeed / TILE_SIZE;
    if (keys['a']) camera.x -= moveSpeed / TILE_SIZE;
    if (keys['d']) camera.x += moveSpeed / TILE_SIZE;
    if (keys['q']) camera.zoom *= (1 + dt);
    if (keys['e']) camera.zoom *= (1 - dt);
    camera.zoom = Math.max(0.3, Math.min(camera.zoom, 4));
  }

  function initGame(reseed=false) {
    if (!reseed) GAME_SEED = parseSeed();
    rng = mulberry32(GAME_SEED);
    
    base = { x: 0, y: 0 };
    chunks = new Map();
    gems = 150; lives = 20; towers = []; enemies = []; projectiles = []; spawnPoints = [];
    
    // Initial reveal and spawner setup
    revealArea(base.x, base.y, 4);
    
    placeTower(base.x + 1, base.y, TOWER.LIGHTER);

    lastFrameTime = performance.now();
    lastSpawn = 0;

    camera.zoom = 1;
    camera.x = base.x + 0.5 - (CANVAS_W / 2 / TILE_SIZE);
    camera.y = base.y + 0.5 - (CANVAS_H / 2 / TILE_SIZE);
  }

  window.addEventListener('resize', () => {
    CANVAS_W = window.innerWidth - 30; CANVAS_H = window.innerHeight - 150;
    canvas.width = CANVAS_W; canvas.height = CANVAS_H;
  });

  initGame(false);
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
