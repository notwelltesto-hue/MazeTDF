<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Maze TD - Infinite & Dynamic Spawns</title>
  <style>
    body { background:#111; color:#ddd; font-family: sans-serif; display:flex; flex-direction:column; align-items:center; padding:12px; margin: 0; overflow: hidden; }
    canvas { background:#000; image-rendering: crisp-edges; border:4px solid #222; }
    .info { margin-top:8px; }
    .hint { color:#aaa; font-size:13px; }
  </style>
</head>
<body>
  <h2 style="color:white">Maze Tower Defense â€” Infinite & Dynamic Spawns</h2>
  <canvas id="game"></canvas>
  <div class="info">
    <div id="hud"></div>
    <div class="hint">Keys: 1=Basic, 2=Lighter, 3=Mine, R=random seed. WASD to move camera, Q/E to zoom.</div>
  </div>

<script>
(() => {
  // ---------- Config ----------
  let TILE = 32;
  let COLS = 30;
  let ROWS = 30;
  let CANVAS_W = window.innerWidth - 30;
  let CANVAS_H = window.innerHeight - 150;
  const spawnIntervalMs = 1700;
  const EXPANSION_AMOUNT = 15;

  const COST = { basic: 20, lighter: 30, mine: 50 };
  const TOWER = { BASIC: 'basic', LIGHTER: 'lighter', MINE: 'mine' };
  let selectedTower = TOWER.BASIC;

  const canvas = document.getElementById('game');
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;
  const ctx = canvas.getContext('2d');

  let gems, lives, maze, fog, gemNode, generated, towers, enemies, projectiles, spawnPoints, base;
  let lastSpawn = 0;

  const camera = { x: 0, y: 0, zoom: 1, speed: 400 };
  const keys = {};

  function mulberry32(a) {
    return function() {
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = t + Math.imul(t ^ (t >>> 7), 61 | t) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function parseSeed() {
    const params = new URLSearchParams(location.search);
    const p = params.get('seed');
    if (p) return Number(p) || 0;
    return Math.floor(Math.random()*0x7fffffff);
  }

  let GAME_SEED = parseSeed();
  let rng = mulberry32(GAME_SEED);

  function setSeed(newSeed) {
    GAME_SEED = newSeed | 0;
    rng = mulberry32(GAME_SEED);
    initGame(true);
  }

  function initGrid(rows, cols) {
    ROWS = rows;
    COLS = cols;
    maze = Array.from({length: ROWS}, () => Array(COLS).fill(null));
    fog = Array.from({length: ROWS}, () => Array(COLS).fill(true));
    gemNode = Array.from({length: ROWS}, () => Array(COLS).fill(false));
    generated = Array.from({length: ROWS}, () => Array(COLS).fill(false));
  }

    function expandWorld(expandTop, expandRight, expandBottom, expandLeft) {
        let shiftX = 0, shiftY = 0;

        if (expandTop) {
            shiftY = EXPANSION_AMOUNT;
            const newRows = Array.from({ length: EXPANSION_AMOUNT }, () => Array(COLS).fill(null));
            maze.unshift(...newRows);
            fog.unshift(...newRows.map(r => r.map(() => true)));
            gemNode.unshift(...newRows);
            generated.unshift(...newRows);
            ROWS += EXPANSION_AMOUNT;
        }
        if (expandBottom) {
            const newRows = Array.from({ length: EXPANSION_AMOUNT }, () => Array(COLS).fill(null));
            maze.push(...newRows);
            fog.push(...newRows.map(r => r.map(() => true)));
            gemNode.push(...newRows);
            generated.push(...newRows);
            ROWS += EXPANSION_AMOUNT;
        }
        if (expandLeft) {
            shiftX = EXPANSION_AMOUNT;
            for (let y = 0; y < ROWS; y++) {
                const newCells = Array(EXPANSION_AMOUNT).fill(null);
                maze[y].unshift(...newCells);
                fog[y].unshift(...Array(EXPANSION_AMOUNT).fill(true));
                gemNode[y].unshift(...newCells);
                generated[y].unshift(...newCells);
            }
            COLS += EXPANSION_AMOUNT;
        }
        if (expandRight) {
             for (let y = 0; y < ROWS; y++) {
                const newCells = Array(EXPANSION_AMOUNT).fill(null);
                maze[y].push(...newCells);
                fog[y].push(...Array(EXPANSION_AMOUNT).fill(true));
                gemNode[y].push(...newCells);
                generated[y].push(...newCells);
            }
            COLS += EXPANSION_AMOUNT;
        }

        if (shiftX > 0 || shiftY > 0) {
            base.x += shiftX; base.y += shiftY;
            towers.forEach(t => { t.x += shiftX; t.y += shiftY; });
            enemies.forEach(e => {
                e.x += shiftX; e.y += shiftY;
                e.path.forEach(p => { p.x += shiftX; p.y += shiftY; });
            });
            projectiles.forEach(p => { p.x += shiftX; p.y += shiftY; });
            spawnPoints.forEach(sp => { sp.x += shiftX; sp.y += shiftY; });
            camera.x += shiftX * TILE;
            camera.y += shiftY * TILE;
        }

        if (expandTop) findAndAddSpawnPoints('top');
        if (expandRight) findAndAddSpawnPoints('right');
        if (expandBottom) findAndAddSpawnPoints('bottom');
        if (expandLeft) findAndAddSpawnPoints('left');
    }

  function findAndAddSpawnPoints(edge) {
      let potentialSpawns = [];
      const minSpawnDist = 10;

      let xStart=0, xEnd=COLS, yStart=0, yEnd=ROWS;
      if(edge === 'top') { yEnd = EXPANSION_AMOUNT; }
      else if(edge === 'bottom') { yStart = ROWS - EXPANSION_AMOUNT; }
      else if(edge === 'left') { xEnd = EXPANSION_AMOUNT; }
      else if(edge === 'right') { xStart = COLS - EXPANSION_AMOUNT; }

      for(let y = yStart; y < yEnd; y++) {
          for(let x = xStart; x < xEnd; x++) {
              if(!generated[y][x]) {
                  const det = deterministicTile(x,y);
                  maze[y][x] = det.tile;
                  gemNode[y][x] = det.gem;
                  generated[y][x] = true;
              }
              if(maze[y][x] === 0) { // Is a path
                  let tooClose = false;
                  for(const sp of spawnPoints) {
                      if(Math.hypot(sp.x - x, sp.y - y) < minSpawnDist) {
                          tooClose = true;
                          break;
                      }
                  }
                  if(!tooClose) potentialSpawns.push({x,y});
              }
          }
      }

      potentialSpawns = potentialSpawns.filter(sp => findPath(sp, base) !== null);
      if(potentialSpawns.length > 0) {
        spawnPoints.push(potentialSpawns[Math.floor(rng() * potentialSpawns.length)]);
      }
  }

  function deterministicTile(x,y) {
    const h = (GAME_SEED ^ (x*374761393) ^ (y*668265263)) >>> 0;
    const cellRng = mulberry32(h);
    const isWall = cellRng() < 0.28 ? 1 : 0;
    const hasGemNode = (!isWall) && (cellRng() < 0.12);
    return { tile: isWall, gem: hasGemNode };
  }

  function generateAreaAround(cx, cy, radius) {
    for (let y = cy - radius; y <= cy + radius; y++) {
      for (let x = cx - radius; x <= cx + radius; x++) {
        if (inBounds(x,y) && !generated[y][x]) {
          const det = deterministicTile(x,y);
          maze[y][x] = det.tile;
          gemNode[y][x] = det.gem;
          generated[y][x] = true;
        }
      }
    }
  }

  function revealArea(cx, cy, radius) {
    for (let y = cy - radius; y <= cy + radius; y++) {
      for (let x = cx - radius; x <= cx + radius; x++) {
        if (inBounds(x,y)) {
          if (!generated[y][x]) {
            generateAreaAround(x, y, 1);
          }
          fog[y][x] = false;
        }
      }
    }
    for (const e of enemies) {
      recomputeEnemyPath(e);
    }
  }

  function findPath(start, goal) {
    if (!inBounds(start.x,start.y) || !inBounds(goal.x,goal.y) || maze[goal.y][goal.x] !== 0) return null;
    const q = [{x:start.x,y:start.y}];
    const visited = Array.from({length:ROWS}, () => Array(COLS).fill(false));
    visited[start.y][start.x] = true;
    const prev = new Map();
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while (q.length) {
      const cur = q.shift();
      if (cur.x === goal.x && cur.y === goal.y) {
        const path = [];
        let p = cur;
        while (p) {
          path.unshift({x:p.x,y:p.y});
          p = prev.get(`${p.x},${p.y}`);
        }
        return path;
      }
      for (const d of dirs) {
        const nx = cur.x + d[0], ny = cur.y + d[1];
        if (inBounds(nx,ny) && !visited[ny][nx] && maze[ny][nx] === 0) {
          visited[ny][nx] = true;
          prev.set(`${nx},${ny}`, cur);
          q.push({x:nx,y:ny});
        }
      }
    }
    return null;
  }

  function inBounds(x,y) { return x>=0 && x<COLS && y>=0 && y<ROWS; }

  function canPlaceTower(x,y,type) {
    if (!inBounds(x,y) || !generated[y][x] || fog[y][x] || maze[y][x] === 1) return false;
    if (towers.some(t => t.x===x && t.y===y)) return false;
    if (type === TOWER.MINE && !gemNode[y][x]) return false;
    if (spawnPoints.some(sp => sp.x===x && sp.y===y)) return false;
    if (x === base.x && y === base.y) return false;
    return true;
  }

  function placeTower(x,y,type) {
    if (!canPlaceTower(x,y,type)) return;
    const cost = COST[type];
    if (gems < cost) return;
    gems -= cost;
    const tower = { x, y, type, cooldown: 0, fireRate: type===TOWER.BASIC ? 0.6 : 2.0, range: type===TOWER.BASIC ? 3.2 : 0, angle: 0, mineTimer: 0 };
    towers.push(tower);
    if (type === TOWER.LIGHTER) {
      revealArea(x,y,4);
    }
  }

  function spawnEnemy() {
    if (spawnPoints.length === 0) return;
    const spawnPoint = spawnPoints[Math.floor(rng() * spawnPoints.length)];
    const path = findPath(spawnPoint, base);
    if (!path) return;
    const maxHp = 20 + Math.floor(rng()*20) + Math.floor(lastFrameTime/30000); // Scale with time
    enemies.push({ path, idx: 0, x: path[0].x + 0.5, y: path[0].y + 0.5, speed: 1.2 + rng() * 0.6, hp: maxHp, maxHp });
  }

  function recomputeEnemyPath(e) {
    const sx = Math.max(0, Math.min(COLS-1, Math.floor(e.x)));
    const sy = Math.max(0, Math.min(ROWS-1, Math.floor(e.y)));
    const p = findPath({x:sx,y:sy}, base);
    if (p) {
      e.path = p;
      e.idx = 0;
    }
  }

  function updateEnemies(dt) {
    for (let i = enemies.length-1; i>=0; i--) {
      const e = enemies[i];
      if (!e.path || e.idx >= e.path.length - 1) {
        if(e.path) lives -= 1;
        enemies.splice(i,1);
        continue;
      }
      const target = e.path[e.idx+1];
      const tx = target.x + 0.5, ty = target.y + 0.5;
      const dx = tx - e.x, dy = ty - e.y;
      const dist = Math.hypot(dx,dy);
      const move = e.speed * dt;
      if (dist <= move) {
        e.x = tx; e.y = ty; e.idx++;
      } else {
        e.x += (dx/dist) * move;
        e.y += (dy/dist) * move;
      }
    }
  }

  function updateTowers(dt) {
    for (const t of towers) {
      if (t.type === TOWER.BASIC) {
        t.cooldown -= dt;
        let target = null;
        let best = Infinity;
        for (const e of enemies) {
           const d = Math.hypot((t.x + 0.5) - e.x, (t.y + 0.5) - e.y);
          if (d <= t.range && d < best) { best = d; target = e; }
        }
        if (target) {
          const tx = target.x - (t.x + 0.5);
          const ty = target.y - (t.y + 0.5);
          const desired = Math.atan2(ty, tx);
          const diff = normalizeAngle(desired - t.angle);
          const rotSpeed = 7.0 * dt;
          t.angle += Math.sign(diff) * Math.min(Math.abs(diff), rotSpeed);
          if (t.cooldown <= 0 && Math.abs(diff) < 0.1) {
            projectiles.push({ x: t.x + 0.5, y: t.y + 0.5, vx: Math.cos(t.angle) * 8.0, vy: Math.sin(t.angle) * 8.0, target: target, life: 1.2 });
            t.cooldown = t.fireRate;
          }
        } else {
          t.angle += 0.5 * dt;
        }
      } else if (t.type === TOWER.MINE) {
        t.mineTimer += dt;
        if (t.mineTimer >= 3.5) {
          gems += 10 + Math.floor(rng()*8);
          t.mineTimer = 0;
        }
      }
    }
    for (let i=enemies.length-1;i>=0;i--) {
      if (enemies[i].hp <= 0) {
        gems += 5 + Math.floor(rng()*5);
        enemies.splice(i,1);
      }
    }
  }

  function normalizeAngle(a) {
    while (a > Math.PI) a -= Math.PI*2;
    while (a < -Math.PI) a += Math.PI*2;
    return a;
  }

  function updateProjectiles(dt) {
    for (let i=projectiles.length-1;i>=0;i--) {
      const p = projectiles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.target && p.target.hp > 0 && Math.hypot(p.x - p.target.x, p.y - p.target.y) < 0.5) {
        p.target.hp -= 7;
        projectiles.splice(i,1);
        continue;
      }
      if (p.life <= 0 || (p.target && p.target.hp <=0)) projectiles.splice(i,1);
    }
  }

  function drawGrid() {
        const view = { x: camera.x, y: camera.y, w: CANVAS_W, h: CANVAS_H };
        const startCol = Math.floor(view.x / TILE);
        const endCol = Math.ceil((view.x + view.w / camera.zoom) / TILE);
        const startRow = Math.floor(view.y / TILE);
        const endRow = Math.ceil((view.y + view.h / camera.zoom) / TILE);

        for (let y = startRow; y < endRow; y++) {
            for (let x = startCol; x < endCol; x++) {
                if (!inBounds(x,y)) continue;
                const px = x * TILE, py = y * TILE;
                if (fog[y][x]) {
                    ctx.fillStyle = '#0c0c0c';
                    ctx.fillRect(px, py, TILE, TILE);
                } else {
                    ctx.fillStyle = maze[y][x] === 1 ? '#3a3a3a' : '#bdbdbd';
                    ctx.fillRect(px, py, TILE, TILE);
                    if(maze[y][x] === 0) {
                        ctx.strokeStyle = '#a6a6a6';
                        ctx.strokeRect(px, py, TILE, TILE);
                    }
                    if (gemNode[y][x]) {
                        ctx.fillStyle = '#8ff';
                        ctx.beginPath();
                        ctx.arc(px + TILE * 0.75, py + TILE * 0.25, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        ctx.fillStyle = '#444';
        ctx.fillRect(base.x * TILE, base.y * TILE, TILE, TILE);
        ctx.fillStyle = '#222';
        ctx.fillRect(base.x * TILE + 6, base.y * TILE + 6, TILE - 12, TILE - 12);

        spawnPoints.forEach(sp => {
            ctx.fillStyle = 'rgba(150, 0, 0, 0.7)';
            ctx.fillRect(sp.x * TILE, sp.y * TILE, TILE, TILE);
            ctx.strokeStyle = 'red';
            ctx.strokeRect(sp.x*TILE + 4, sp.y*TILE+4, TILE-8, TILE-8);
        });
    }

  function drawTowers() {
    for (const t of towers) {
      const cx = t.x*TILE + TILE/2;
      const cy = t.y*TILE + TILE/2;
      if (t.type === TOWER.BASIC) {
        ctx.fillStyle = 'blue';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.3, 0, Math.PI*2); ctx.fill();
        ctx.save();
        ctx.translate(cx,cy);
        ctx.rotate(t.angle);
        ctx.fillStyle = '#0033cc';
        ctx.fillRect(0, -5, TILE*0.45, 10);
        ctx.restore();
      } else if (t.type === TOWER.LIGHTER) {
        ctx.fillStyle = 'gold';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.3, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,230,100,0.1)';
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(cx,cy, TILE*4, 0, Math.PI*2); ctx.stroke();
        ctx.lineWidth = 1;
      } else if (t.type === TOWER.MINE) {
        ctx.fillStyle = 'green';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.28, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0a0';
        ctx.fillRect(cx-6, cy+4, 12, 6);
      }
    }
  }

  function drawEnemies() {
    for (const e of enemies) {
      const cx = e.x * TILE;
      const cy = e.y * TILE;
      ctx.fillStyle = 'crimson';
      ctx.fillRect(cx - 10, cy - 10, 20, 20);
      const hpFrac = Math.max(0, e.hp) / e.maxHp;
      ctx.fillStyle = '#222';
      ctx.fillRect(cx - 12, cy - 16, 24, 4);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(cx - 12, cy - 16, 24 * hpFrac, 4);
    }
  }

  function drawProjectiles() {
    ctx.fillStyle = 'yellow';
    for (const p of projectiles) {
      ctx.beginPath();
      ctx.arc(p.x * TILE, p.y * TILE, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawHUD() {
    const hud = document.getElementById('hud');
    hud.innerHTML = `Seed: <b>${GAME_SEED}</b> &nbsp; Gems: <b>${gems}</b> &nbsp; Lives: <b>${lives}</b> &nbsp; Selected: <b>${selectedTower}</b> &nbsp; Cost: ${COST[selectedTower] || '-'}`;
  }

  function screenToWorld(x, y) {
        const worldX = (x / camera.zoom) + camera.x;
        const worldY = (y / camera.zoom) + camera.y;
        return { x: worldX, y: worldY };
    }

  canvas.addEventListener('click', (ev) => {
        const rect = canvas.getBoundingClientRect();
        const worldCoords = screenToWorld(ev.clientX - rect.left, ev.clientY - rect.top);
        placeTower(Math.floor(worldCoords.x / TILE), Math.floor(worldCoords.y / TILE), selectedTower);
    });

  document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === '1') selectedTower = TOWER.BASIC;
    else if (e.key === '2') selectedTower = TOWER.LIGHTER;
    else if (e.key === '3') selectedTower = TOWER.MINE;
    else if (e.key.toLowerCase() === 'r') {
      setSeed(Math.floor(Math.random()*0x7fffffff));
    }
  });

  document.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  let lastFrameTime = performance.now();
  function gameLoop(now) {
        const dt = Math.min(0.1, (now - lastFrameTime) / 1000);
        lastFrameTime = now;

        updateCamera(dt);
        
        const view = { x: camera.x, y: camera.y, w: CANVAS_W, h: CANVAS_H };
        const startCol = Math.floor(view.x / TILE);
        const endCol = Math.ceil((view.x + view.w / camera.zoom) / TILE);
        const startRow = Math.floor(view.y / TILE);
        const endRow = Math.ceil((view.y + view.h / camera.zoom) / TILE);
        
        if (startCol < 5) expandWorld(false, false, false, true);
        if (endCol > COLS - 5) expandWorld(false, true, false, false);
        if (startRow < 5) expandWorld(true, false, false, false);
        if (endRow > ROWS - 5) expandWorld(false, false, true, false);

        lastSpawn += dt * 1000;
        if (lastSpawn >= spawnIntervalMs) {
            spawnEnemy();
            lastSpawn = 0;
        }

        updateEnemies(dt);
        updateTowers(dt);
        updateProjectiles(dt);

        ctx.save();
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);
        
        drawGrid();
        drawTowers();
        drawEnemies();
        drawProjectiles();

        ctx.restore();
        drawHUD();

        if (lives <= 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            ctx.fillStyle = 'white';
            ctx.font = '36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over', CANVAS_W / 2, CANVAS_H / 2);
        } else {
            requestAnimationFrame(gameLoop);
        }
    }

  function updateCamera(dt) {
    const moveSpeed = camera.speed * dt / camera.zoom;
    if (keys['w']) camera.y -= moveSpeed;
    if (keys['s']) camera.y += moveSpeed;
    if (keys['a']) camera.x -= moveSpeed;
    if (keys['d']) camera.x += moveSpeed;
    if (keys['q']) camera.zoom *= (1 + dt);
    if (keys['e']) camera.zoom *= (1 - dt);
    camera.zoom = Math.max(0.3, Math.min(camera.zoom, 4));
  }

  function initGame(reseed=false) {
    if (!reseed) GAME_SEED = parseSeed();
    rng = mulberry32(GAME_SEED);

    initGrid(30, 30);
    base = { x: Math.floor(COLS/2), y: Math.floor(ROWS/2) };
    
    gems = 150; lives = 15; towers = []; enemies = []; projectiles = []; spawnPoints = [];
    
    generateAreaAround(base.x, base.y, 4);
    revealArea(base.x, base.y, 3);
    
    findAndAddSpawnPoints('top');
    findAndAddSpawnPoints('left');
    
    placeTower(base.x+1, base.y, TOWER.LIGHTER);

    lastFrameTime = performance.now();
    lastSpawn = 0;

    camera.zoom = 1;
    camera.x = (base.x + 0.5) * TILE - (CANVAS_W / 2);
    camera.y = (base.y + 0.5) * TILE - (CANVAS_H / 2);
  }

  window.addEventListener('resize', () => {
    CANVAS_W = window.innerWidth - 30;
    CANVAS_H = window.innerHeight - 150;
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;
  });

  initGame(false);
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
