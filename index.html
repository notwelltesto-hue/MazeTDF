<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Maze TD - Infinite with Camera Controls</title>
  <style>
    body { background:#111; color:#ddd; font-family: sans-serif; display:flex; flex-direction:column; align-items:center; padding:12px; margin: 0; overflow: hidden; }
    canvas { background:#000; image-rendering: crisp-edges; border:4px solid #222; }
    .info { margin-top:8px; }
    .hint { color:#aaa; font-size:13px; }
  </style>
</head>
<body>
  <h2 style="color:white">Maze Tower Defense â€” Infinite with Camera Controls</h2>
  <canvas id="game"></canvas>
  <div class="info">
    <div id="hud"></div>
    <div class="hint">Keys: 1=Basic, 2=Lighter, 3=Mine, R=random seed. WASD to move camera, Q/E to zoom. Click to place towers on revealed path tiles.</div>
  </div>

<script>
(() => {
  // ---------- Config ----------
  let TILE = 32;
  let COLS = 25;
  let ROWS = 25;
  let CANVAS_W = window.innerWidth - 30;
  let CANVAS_H = window.innerHeight - 150;
  const spawnIntervalMs = 1800;

  const COST = { basic: 20, lighter: 30, mine: 50 };
  const TOWER = { BASIC: 'basic', LIGHTER: 'lighter', MINE: 'mine' };
  let selectedTower = TOWER.BASIC;

  const canvas = document.getElementById('game');
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;
  const ctx = canvas.getContext('2d');

  let gems = 120, lives = 10;
  let maze = [];
  let fog = [];
  let gemNode = [];
  let generated = [];
  let towers = [];
  let enemies = [];
  let projectiles = [];
  let lastSpawn = 0;
  let base = { x: Math.floor(COLS/2), y: Math.floor(ROWS/2) };
  let spawnPoint = { x: 0, y: Math.floor(ROWS/2) };

  const camera = {
    x: 0,
    y: 0,
    zoom: 1,
    speed: 400
  };
  const keys = {};

  function mulberry32(a) {
    return function() {
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = t + Math.imul(t ^ (t >>> 7), 61 | t) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function parseSeed() {
    const params = new URLSearchParams(location.search);
    const p = params.get('seed');
    if (p) return Number(p) || 0;
    return Math.floor(Math.random()*0x7fffffff);
  }

  let GAME_SEED = parseSeed();
  let rng = mulberry32(GAME_SEED);

  function setSeed(newSeed) {
    GAME_SEED = newSeed | 0;
    rng = mulberry32(GAME_SEED);
    initGame(true);
  }

  function initGrid(rows, cols) {
    ROWS = rows;
    COLS = cols;
    maze = Array.from({length: rows}, () => Array(cols).fill(null));
    fog = Array.from({length: rows}, () => Array(cols).fill(true));
    gemNode = Array.from({length: rows}, () => Array(cols).fill(false));
    generated = Array.from({length: rows}, () => Array(cols).fill(false));
  }

    function expandWorld(top, right, bottom, left) {
        const expansionAmount = 15;
        if (top) {
            const add = Array.from({length: expansionAmount}, () => Array(COLS).fill(null));
            maze.unshift(...add);
            fog.unshift(...add);
            gemNode.unshift(...add);
            generated.unshift(...add);
            ROWS += expansionAmount;
            const shift = expansionAmount;
            base.y += shift;
            spawnPoint.y += shift;
            towers.forEach(t => t.y += shift);
            enemies.forEach(e => {
                e.y += shift;
                e.path.forEach(p => p.y += shift);
            });
            projectiles.forEach(p => p.y += shift);
            camera.y += shift * TILE;
        }
        if (bottom) {
             const add = Array.from({length: expansionAmount}, () => Array(COLS).fill(null));
            maze.push(...add);
            fog.push(...add);
            gemNode.push(...add);
            generated.push(...add);
            ROWS += expansionAmount;
        }
        if (left) {
            for (let y = 0; y < ROWS; y++) {
                for(let i=0; i<expansionAmount; i++) {
                    maze[y].unshift(null);
                    fog[y].unshift(true);
                    gemNode[y].unshift(false);
                    generated[y].unshift(false);
                }
            }
            COLS += expansionAmount;
            const shift = expansionAmount;
            base.x += shift;
            spawnPoint.x += shift;
            towers.forEach(t => t.x += shift);
            enemies.forEach(e => {
                e.x += shift;
                e.path.forEach(p => p.x += shift);
            });
            projectiles.forEach(p => p.x += shift);
            camera.x += shift * TILE;
        }
        if (right) {
            for (let y = 0; y < ROWS; y++) {
                 for(let i=0; i<expansionAmount; i++) {
                    maze[y].push(null);
                    fog[y].push(true);
                    gemNode[y].push(false);
                    generated[y].push(false);
                }
            }
            COLS += expansionAmount;
        }
    }


  function deterministicTile(x,y) {
    const h = (GAME_SEED ^ (x*374761393) ^ (y*668265263)) >>> 0;
    const cellRng = mulberry32(h);
    const isWall = cellRng() < 0.25 ? 1 : 0;
    const hasGemNode = (!isWall) && (cellRng() < 0.12);
    return { tile: isWall, gem: hasGemNode };
  }

  function generateInitialNeighborhood() {
    generateAreaAround(base.x, base.y, 3);
    spawnPoint.x = rng() < 0.5 ? 0 : COLS-1;
    spawnPoint.y = Math.floor(rng()*ROWS);
    generateAreaAround(spawnPoint.x, spawnPoint.y, 2);
    maze[base.y][base.x] = 0; generated[base.y][base.x] = true; fog[base.y][base.x] = false;
    maze[spawnPoint.y][spawnPoint.x] = 0; generated[spawnPoint.y][spawnPoint.x] = true; fog[spawnPoint.y][spawnPoint.x] = false;
  }

  function generateAreaAround(cx, cy, radius) {
    for (let y = cy - radius; y <= cy + radius; y++) {
      for (let x = cx - radius; x <= cx + radius; x++) {
        if (inBounds(x,y) && !generated[y][x]) {
          const det = deterministicTile(x,y);
          maze[y][x] = det.tile;
          gemNode[y][x] = det.gem;
          generated[y][x] = true;
        }
      }
    }
  }

  function revealArea(cx, cy, radius) {
    for (let y = cy - radius; y <= cy + radius; y++) {
      for (let x = cx - radius; x <= cx + radius; x++) {
        if (inBounds(x,y)) {
          if (!generated[y][x]) {
            const det = deterministicTile(x,y);
            maze[y][x] = det.tile;
            gemNode[y][x] = det.gem;
            generated[y][x] = true;
          }
          fog[y][x] = false;
        }
      }
    }
    for (const e of enemies) {
      recomputeEnemyPath(e);
    }
  }

  function findPath(start, goal) {
    if (!inBounds(start.x,start.y) || !inBounds(goal.x,goal.y)) return null;
    if (maze[goal.y][goal.x] !== 0) return null;
    const q = [];
    const visited = Array.from({length:ROWS}, () => Array(COLS).fill(false));
    const prev = Array.from({length:ROWS}, () => Array(COLS).fill(null));
    q.push({x:start.x,y:start.y});
    visited[start.y][start.x] = true;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while (q.length) {
      const cur = q.shift();
      if (cur.x === goal.x && cur.y === goal.y) {
        const path = [];
        let p = cur;
        while (p) {
          path.push({x:p.x,y:p.y});
          p = prev[p.y][p.x];
        }
        return path.reverse();
      }
      for (const d of dirs) {
        const nx = cur.x + d[0], ny = cur.y + d[1];
        if (inBounds(nx,ny) && !visited[ny][nx] && maze[ny][nx] === 0) {
          visited[ny][nx] = true;
          prev[ny][nx] = cur;
          q.push({x:nx,y:ny});
        }
      }
    }
    return null;
  }

  function inBounds(x,y) { return x>=0 && x<COLS && y>=0 && y<ROWS; }

  function canPlaceTower(x,y,type) {
    if (!inBounds(x,y)) return false;
    if (!generated[y][x] || fog[y][x]) return false;
    if (maze[y][x] === 1) return false;
    if (towers.some(t => t.x===x && t.y===y)) return false;
    if (type === TOWER.MINE && !gemNode[y][x]) return false;
    if (x===spawnPoint.x && y===spawnPoint.y) return false;
    return true;
  }

  function placeTower(x,y,type) {
    if (!canPlaceTower(x,y,type)) return;
    const cost = COST[type];
    if (gems < cost) return;
    gems -= cost;
    const tower = {
      x, y, type,
      cooldown: 0,
      fireRate: type===TOWER.BASIC ? 0.6 : 2.0,
      range: type===TOWER.BASIC ? 3.2 : 0,
      angle: 0,
      mineTimer: 0
    };
    towers.push(tower);
    if (type === TOWER.LIGHTER) {
      revealArea(x,y,4);
    }
  }

  function spawnEnemy() {
    generateAreaAround(spawnPoint.x, spawnPoint.y, 4);
    const path = findPath(spawnPoint, base);
    if (!path) return;
    const maxHp = 20 + Math.floor(rng()*15);
    enemies.push({
      path,
      idx: 0,
      x: path[0].x + 0.5,
      y: path[0].y + 0.5,
      speed: 1.2 + rng() * 0.5,
      hp: maxHp,
      maxHp: maxHp
    });
  }

  function recomputeEnemyPath(e) {
    const sx = Math.max(0, Math.min(COLS-1, Math.floor(e.x)));
    const sy = Math.max(0, Math.min(ROWS-1, Math.floor(e.y)));
    const p = findPath({x:sx,y:sy}, base);
    if (p) {
      e.path = p;
      e.idx = 0;
    }
  }

  function updateEnemies(dt) {
    for (let i = enemies.length-1; i>=0; i--) {
      const e = enemies[i];
      if (!e.path || e.idx >= e.path.length - 1) {
        if(e.path) lives -= 1;
        enemies.splice(i,1);
        continue;
      }
      const target = e.path[e.idx+1];
      const tx = target.x + 0.5, ty = target.y + 0.5;
      const dx = tx - e.x, dy = ty - e.y;
      const dist = Math.hypot(dx,dy);
      const move = e.speed * dt;
      if (dist <= move) {
        e.x = tx; e.y = ty; e.idx++;
      } else {
        e.x += (dx/dist) * move;
        e.y += (dy/dist) * move;
      }
    }
  }

  function updateTowers(dt) {
    for (const t of towers) {
      if (t.type === TOWER.BASIC) {
        t.cooldown -= dt;
        let target = null;
        let best = Infinity;
        for (const e of enemies) {
           const d = Math.hypot((t.x + 0.5) - e.x, (t.y + 0.5) - e.y);
          if (d <= t.range && d < best) { best = d; target = e; }
        }
        if (target) {
          const tx = target.x - (t.x + 0.5);
          const ty = target.y - (t.y + 0.5);
          const desired = Math.atan2(ty, tx);
          const diff = normalizeAngle(desired - t.angle);
          const rotSpeed = 6.0 * dt;
          t.angle += Math.sign(diff) * Math.min(Math.abs(diff), rotSpeed);
          if (t.cooldown <= 0) {
            projectiles.push({
              x: t.x + 0.5, y: t.y + 0.5,
              vx: Math.cos(t.angle) * 8.0, vy: Math.sin(t.angle) * 8.0,
              target: target, life: 1.2
            });
            t.cooldown = t.fireRate;
          }
        } else {
          t.angle += 0.5 * dt;
        }
      } else if (t.type === TOWER.MINE) {
        t.mineTimer += dt;
        if (t.mineTimer >= 3.5) {
          gems += 10 + Math.floor(rng()*8);
          t.mineTimer = 0;
        }
      }
    }
    for (let i=enemies.length-1;i>=0;i--) {
      if (enemies[i].hp <= 0) {
        gems += 5 + Math.floor(rng()*5);
        enemies.splice(i,1);
      }
    }
  }

  function normalizeAngle(a) {
    while (a > Math.PI) a -= Math.PI*2;
    while (a < -Math.PI) a += Math.PI*2;
    return a;
  }

  function updateProjectiles(dt) {
    for (let i=projectiles.length-1;i>=0;i--) {
      const p = projectiles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.target && p.target.hp > 0 && Math.hypot(p.x - p.target.x, p.y - p.target.y) < 0.5) {
        p.target.hp -= 6;
        projectiles.splice(i,1);
        continue;
      }
      if (p.life <= 0) projectiles.splice(i,1);
    }
  }

  function drawGrid() {
        const view = {
            x: camera.x,
            y: camera.y,
            w: CANVAS_W,
            h: CANVAS_H
        };
        const TILE_ZOOMED = TILE * camera.zoom;
        const startCol = Math.floor(view.x / TILE);
        const endCol = Math.ceil((view.x + view.w / camera.zoom) / TILE);
        const startRow = Math.floor(view.y / TILE);
        const endRow = Math.ceil((view.y + view.h / camera.zoom) / TILE);

        for (let y = startRow; y < endRow; y++) {
            for (let x = startCol; x < endCol; x++) {
                if (!inBounds(x,y)) continue;
                const px = x * TILE, py = y * TILE;
                if (fog[y][x]) {
                    ctx.fillStyle = '#0c0c0c';
                    ctx.fillRect(px, py, TILE, TILE);
                } else {
                    ctx.fillStyle = maze[y][x] === 1 ? '#3a3a3a' : '#bdbdbd';
                    ctx.fillRect(px, py, TILE, TILE);
                    if(maze[y][x] === 0) {
                        ctx.strokeStyle = '#a6a6a6';
                        ctx.strokeRect(px, py, TILE, TILE);
                    }
                    if (gemNode[y][x]) {
                        ctx.fillStyle = '#8ff';
                        ctx.beginPath();
                        ctx.arc(px + TILE * 0.75, py + TILE * 0.25, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        ctx.fillStyle = '#444';
        ctx.fillRect(base.x * TILE, base.y * TILE, TILE, TILE);
        ctx.fillStyle = '#222';
        ctx.fillRect(base.x * TILE + 6, base.y * TILE + 6, TILE - 12, TILE - 12);
    }

  function drawTowers() {
    for (const t of towers) {
      const cx = t.x*TILE + TILE/2;
      const cy = t.y*TILE + TILE/2;
      if (t.type === TOWER.BASIC) {
        ctx.fillStyle = 'blue';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.3, 0, Math.PI*2); ctx.fill();
        ctx.save();
        ctx.translate(cx,cy);
        ctx.rotate(t.angle);
        ctx.fillStyle = '#0033cc';
        ctx.fillRect(0, -5, TILE*0.45, 10);
        ctx.restore();
      } else if (t.type === TOWER.LIGHTER) {
        ctx.fillStyle = 'gold';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.3, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,230,100,0.1)';
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(cx,cy, TILE*4, 0, Math.PI*2); ctx.stroke();
        ctx.lineWidth = 1;
      } else if (t.type === TOWER.MINE) {
        ctx.fillStyle = 'green';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.28, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0a0';
        ctx.fillRect(cx-6, cy+4, 12, 6);
      }
    }
  }

  function drawEnemies() {
    for (const e of enemies) {
      const cx = e.x * TILE;
      const cy = e.y * TILE;
      ctx.fillStyle = 'crimson';
      ctx.fillRect(cx - 10, cy - 10, 20, 20);
      // FIX: Use maxHp for stable health bar
      const hpFrac = Math.max(0, e.hp) / e.maxHp;
      ctx.fillStyle = '#222';
      ctx.fillRect(cx - 12, cy - 16, 24, 4);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(cx - 12, cy - 16, 24 * hpFrac, 4);
    }
  }

  function drawProjectiles() {
    ctx.fillStyle = 'yellow';
    for (const p of projectiles) {
      ctx.beginPath();
      ctx.arc(p.x * TILE, p.y * TILE, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawHUD() {
    const hud = document.getElementById('hud');
    hud.innerHTML = `Seed: <b>${GAME_SEED}</b> &nbsp; Gems: <b>${gems}</b> &nbsp; Lives: <b>${lives}</b> &nbsp; Selected: <b>${selectedTower}</b> &nbsp; Cost: ${COST[selectedTower] || '-'}`;
  }

  function screenToWorld(x, y) {
        // FIX: Corrected the math for screen to world transformation
        const worldX = (x / camera.zoom) + camera.x;
        const worldY = (y / camera.zoom) + camera.y;
        return { x: worldX, y: worldY };
    }

  canvas.addEventListener('click', (ev) => {
        const rect = canvas.getBoundingClientRect();
        const mx = ev.clientX - rect.left;
        const my = ev.clientY - rect.top;
        const worldCoords = screenToWorld(mx, my);
        const gx = Math.floor(worldCoords.x / TILE);
        const gy = Math.floor(worldCoords.y / TILE);
        placeTower(gx, gy, selectedTower);
    });

  document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === '1') selectedTower = TOWER.BASIC;
    else if (e.key === '2') selectedTower = TOWER.LIGHTER;
    else if (e.key === '3') selectedTower = TOWER.MINE;
    else if (e.key.toLowerCase() === 'r') {
      const newSeed = Math.floor(Math.random()*0x7fffffff);
      setSeed(newSeed);
    }
  });

  document.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  let lastFrameTime = performance.now();
  function gameLoop(now) {
        const dt = Math.min(0.1, (now - lastFrameTime) / 1000);
        lastFrameTime = now;

        updateCamera(dt);
        
        // FIX: Moved world expansion logic before any updates or drawing
        const view = { x: camera.x, y: camera.y, w: CANVAS_W, h: CANVAS_H };
        const TILE_ZOOMED = TILE * camera.zoom;
        const startCol = Math.floor(view.x / TILE);
        const endCol = Math.ceil((view.x + view.w / camera.zoom) / TILE);
        const startRow = Math.floor(view.y / TILE);
        const endRow = Math.ceil((view.y + view.h / camera.zoom) / TILE);
        
        if (startCol < 2) expandWorld(false, false, false, true);
        if (endCol > COLS - 2) expandWorld(false, true, false, false);
        if (startRow < 2) expandWorld(true, false, false, false);
        if (endRow > ROWS - 2) expandWorld(false, false, true, false);

        lastSpawn += dt * 1000;
        if (lastSpawn >= spawnIntervalMs) {
            spawnEnemy();
            lastSpawn = 0;
        }

        updateEnemies(dt);
        updateTowers(dt);
        updateProjectiles(dt);

        ctx.save();
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);
        
        drawGrid();
        drawTowers();
        drawEnemies();
        drawProjectiles();

        ctx.restore();
        drawHUD();

        if (lives <= 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            ctx.fillStyle = 'white';
            ctx.font = '36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over', CANVAS_W / 2, CANVAS_H / 2);
        } else {
            requestAnimationFrame(gameLoop);
        }
    }

  function updateCamera(dt) {
    if (keys['w']) camera.y -= camera.speed * dt / camera.zoom;
    if (keys['s']) camera.y += camera.speed * dt / camera.zoom;
    if (keys['a']) camera.x -= camera.speed * dt / camera.zoom;
    if (keys['d']) camera.x += camera.speed * dt / camera.zoom;
    if (keys['q']) camera.zoom *= (1 + dt);
    if (keys['e']) camera.zoom *= (1 - dt);
    camera.zoom = Math.max(0.3, Math.min(camera.zoom, 4));
  }

  function initGame(reseed=false) {
    if (!reseed) {
      GAME_SEED = parseSeed();
    }
    rng = mulberry32(GAME_SEED);

    COLS = 25;
    ROWS = 25;
    base = { x: Math.floor(COLS/2), y: Math.floor(ROWS/2) };
    
    gems = 120; lives = 10; towers = []; enemies = []; projectiles = [];
    initGrid(ROWS, COLS);
    generateInitialNeighborhood();
    
    // Place initial tower at base (must be after towers array is cleared)
    placeTower(base.x, base.y, TOWER.LIGHTER);

    lastFrameTime = performance.now();
    lastSpawn = 0;

    camera.zoom = 1;
    // Center camera on the base's center
    camera.x = (base.x + 0.5) * TILE - (CANVAS_W / 2 / camera.zoom);
    camera.y = (base.y + 0.5) * TILE - (CANVAS_H / 2 / camera.zoom);
  }

  window.__td = { setSeed, getSeed: () => GAME_SEED, rng, maze, fog, gemNode, towers, enemies };

  initGame(false);
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
