<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Maze TD - Infinite with Camera Controls</title>
  <style>
    body { background:#111; color:#ddd; font-family: sans-serif; display:flex; flex-direction:column; align-items:center; padding:12px; margin: 0; overflow: hidden; }
    canvas { background:#000; image-rendering: crisp-edges; border:4px solid #222; }
    .info { margin-top:8px; }
    .hint { color:#aaa; font-size:13px; }
  </style>
</head>
<body>
  <h2 style="color:white">Maze Tower Defense â€” Infinite with Camera Controls</h2>
  <canvas id="game"></canvas>
  <div class="info">
    <div id="hud"></div>
    <div class="hint">Keys: 1=Basic, 2=Lighter, 3=Mine, R=random seed. WASD to move camera, Q/E to zoom. Click to place towers on revealed path tiles.</div>
  </div>

<script>
(() => {
  // ---------- Config ----------
  let TILE = 32;
  let COLS = 25;
  let ROWS = 25;
  let CANVAS_W = window.innerWidth - 30;
  let CANVAS_H = window.innerHeight - 150;
  const spawnIntervalMs = 1800;

  const COST = { basic: 20, lighter: 30, mine: 50 };
  const TOWER = { BASIC: 'basic', LIGHTER: 'lighter', MINE: 'mine' };
  let selectedTower = TOWER.BASIC;

  const canvas = document.getElementById('game');
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;
  const ctx = canvas.getContext('2d');

  let gems = 120, lives = 10;
  let maze = [];   // values: null = unknown, 0 = path, 1 = wall
  let fog = [];    // booleans
  let gemNode = []; // chance tile for mine
  let generated = []; // whether cell generated/determined
  let towers = [];
  let enemies = [];
  let projectiles = [];
  let lastSpawn = 0;
  let base = { x: Math.floor(COLS/2), y: Math.floor(ROWS/2) };
  let spawnPoint = { x: 0, y: Math.floor(ROWS/2) };

  const camera = {
    x: 0,
    y: 0,
    zoom: 1,
    speed: 300
  };
  const keys = {};

  // Seeded RNG (mulberry32)
  function mulberry32(a) {
    return function() {
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = t + Math.imul(t ^ (t >>> 7), 61 | t) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function parseSeed() {
    const params = new URLSearchParams(location.search);
    const p = params.get('seed');
    if (p) return Number(p) || 0;
    return Math.floor(Math.random()*0x7fffffff);
  }

  let GAME_SEED = parseSeed();
  let rng = mulberry32(GAME_SEED);

  function setSeed(newSeed) {
    GAME_SEED = newSeed | 0;
    rng = mulberry32(GAME_SEED);
    initGame(true);
  }

  function initGrid(rows, cols) {
    maze = Array.from({length: rows}, () => Array(cols).fill(null));
    fog = Array.from({length: rows}, () => Array(cols).fill(true));
    gemNode = Array.from({length: rows}, () => Array(cols).fill(false));
    generated = Array.from({length: rows}, () => Array(cols).fill(false));
  }

    function expandWorld(top, right, bottom, left) {
        if (top > 0) {
            for (let i = 0; i < top; i++) {
                maze.unshift(Array(COLS).fill(null));
                fog.unshift(Array(COLS).fill(true));
                gemNode.unshift(Array(COLS).fill(false));
                generated.unshift(Array(COLS).fill(false));
            }
            ROWS += top;
            base.y += top;
            spawnPoint.y += top;
            towers.forEach(t => t.y += top);
            enemies.forEach(e => {
                e.y += top;
                e.path.forEach(p => p.y +=top);
            });
             projectiles.forEach(p => p.y += top);
        }
        if (bottom > 0) {
            for (let i = 0; i < bottom; i++) {
                maze.push(Array(COLS).fill(null));
                fog.push(Array(COLS).fill(true));
                gemNode.push(Array(COLS).fill(false));
                generated.push(Array(COLS).fill(false));
            }
            ROWS += bottom;
        }
        if (left > 0) {
            for (let y = 0; y < ROWS; y++) {
                for (let i = 0; i < left; i++) {
                    maze[y].unshift(null);
                    fog[y].unshift(true);
                    gemNode[y].unshift(false);
                    generated[y].unshift(false);
                }
            }
            COLS += left;
            base.x += left;
            spawnPoint.x += left;
            towers.forEach(t => t.x += left);
            enemies.forEach(e => {
                e.x += left;
                e.path.forEach(p => p.x +=left);
            });
            projectiles.forEach(p => p.x += left);
        }
        if (right > 0) {
            for (let y = 0; y < ROWS; y++) {
                for (let i = 0; i < right; i++) {
                    maze[y].push(null);
                    fog[y].push(true);
                    gemNode[y].push(false);
                    generated[y].push(false);
                }
            }
            COLS += right;
        }
    }


  function deterministicTile(x,y) {
    const h = (GAME_SEED ^ (x*374761393) ^ (y*668265263)) >>> 0;
    const cellRng = mulberry32(h);
    const isWall = cellRng() < 0.2 ? 1 : 0;
    const hasGemNode = (!isWall) && (cellRng() < 0.12);
    return { tile: isWall, gem: hasGemNode };
  }

  function generateInitialNeighborhood() {
    generateAreaAround(base.x, base.y, 3);
    spawnPoint.x = rng() < 0.5 ? 0 : COLS-1;
    spawnPoint.y = Math.floor(rng()*ROWS);
    generateAreaAround(spawnPoint.x, spawnPoint.y, 2);
    maze[base.y][base.x] = 0; generated[base.y][base.x] = true; fog[base.y][base.x] = false;
    maze[spawnPoint.y][spawnPoint.x] = 0; generated[spawnPoint.y][spawnPoint.x] = true; fog[spawnPoint.y][spawnPoint.x] = false;
  }

  function generateAreaAround(cx, cy, radius) {
    for (let y = cy - radius; y <= cy + radius; y++) {
      for (let x = cx - radius; x <= cx + radius; x++) {
        if (inBounds(x,y) && !generated[y][x]) {
          const det = deterministicTile(x,y);
          maze[y][x] = det.tile;
          gemNode[y][x] = det.gem;
          generated[y][x] = true;
        }
      }
    }
  }

  function revealArea(cx, cy, radius) {
    for (let y = cy - radius; y <= cy + radius; y++) {
      for (let x = cx - radius; x <= cx + radius; x++) {
        if (inBounds(x,y)) {
          if (!generated[y][x]) {
            const det = deterministicTile(x,y);
            maze[y][x] = det.tile;
            gemNode[y][x] = det.gem;
            generated[y][x] = true;
          }
          fog[y][x] = false;
        }
      }
    }
    for (const e of enemies) {
      recomputeEnemyPath(e);
    }
  }

  function findPath(start, goal) {
    if (!inBounds(start.x,start.y) || !inBounds(goal.x,goal.y)) return null;
    if (maze[goal.y][goal.x] !== 0) return null;
    const q = [];
    const visited = Array.from({length:ROWS}, () => Array(COLS).fill(false));
    const prev = Array.from({length:ROWS}, () => Array(COLS).fill(null));
    q.push({x:start.x,y:start.y});
    visited[start.y][start.x] = true;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while (q.length) {
      const cur = q.shift();
      if (cur.x === goal.x && cur.y === goal.y) {
        const path = [];
        let p = cur;
        while (p) {
          path.push({x:p.x,y:p.y});
          p = prev[p.y][p.x];
        }
        return path.reverse();
      }
      for (const d of dirs) {
        const nx = cur.x + d[0], ny = cur.y + d[1];
        if (inBounds(nx,ny) && !visited[ny][nx] && maze[ny][nx] === 0) {
          visited[ny][nx] = true;
          prev[ny][nx] = cur;
          q.push({x:nx,y:ny});
        }
      }
    }
    return null;
  }

  function inBounds(x,y) { return x>=0 && x<COLS && y>=0 && y<ROWS; }

  function canPlaceTower(x,y,type) {
    if (!inBounds(x,y)) return false;
    if (!generated[y][x] || fog[y][x]) return false;
    if (maze[y][x] === 1) return false;
    if (towers.some(t => t.x===x && t.y===y)) return false;
    if (type === TOWER.MINE && !gemNode[y][x]) return false;
    if (x===spawnPoint.x && y===spawnPoint.y) return false;
    return true;
  }

  function placeTower(x,y,type) {
    if (!canPlaceTower(x,y,type)) return;
    const cost = COST[type];
    if (gems < cost) return;
    gems -= cost;
    if (type === TOWER.LIGHTER) {
      revealArea(x,y,4);
    }
    const tower = {
      x, y, type,
      cooldown: 0,
      fireRate: type===TOWER.BASIC ? 0.6 : 2.0,
      range: type===TOWER.BASIC ? 3.2 : 0,
      angle: 0,
      mineTimer: 0
    };
    towers.push(tower);
  }

  function spawnEnemy() {
    const p = findPath(spawnPoint, base);
    if (!p) {
      generateAreaAround(spawnPoint.x, spawnPoint.y, Math.max(2, Math.floor(Math.max(COLS,ROWS)/6)));
    }
    const final = findPath(spawnPoint, base);
    if (!final) return;
    enemies.push({
      path: final,
      idx: 0,
      x: final[0].x + 0.5,
      y: final[0].y + 0.5,
      speed: 1.2,
      hp: 12 + Math.floor(rng()*8)
    });
  }

  function recomputeEnemyPath(e) {
    const sx = Math.max(0, Math.min(COLS-1, Math.floor(e.x)));
    const sy = Math.max(0, Math.min(ROWS-1, Math.floor(e.y)));
    const p = findPath({x:sx,y:sy}, base);
    if (p) {
      e.path = p;
      e.idx = 0;
    }
  }

  function updateEnemies(dt) {
    for (let i = enemies.length-1; i>=0; i--) {
      const e = enemies[i];
      if (!e.path || e.path.length === 0) { enemies.splice(i,1); continue; }
      if (e.idx >= e.path.length - 1) {
        lives -= 1;
        enemies.splice(i,1);
        continue;
      }
      const target = e.path[e.idx+1];
      const tx = target.x + 0.5, ty = target.y + 0.5;
      const dx = tx - e.x, dy = ty - e.y;
      const dist = Math.hypot(dx,dy);
      const move = e.speed * dt;
      if (dist <= move) {
        e.x = tx; e.y = ty; e.idx++;
      } else {
        e.x += (dx/dist) * move;
        e.y += (dy/dist) * move;
      }
    }
  }

  function updateTowers(dt) {
    for (const t of towers) {
      if (t.type === TOWER.BASIC) {
        t.cooldown -= dt;
        let target = null;
        let best = Infinity;
        for (const e of enemies) {
           const d = Math.hypot((t.x + 0.5) - e.x, (t.y + 0.5) - e.y);
          if (d <= t.range && d < best) { best = d; target = e; }
        }
        if (target) {
          const tx = target.x - (t.x + 0.5);
          const ty = target.y - (t.y + 0.5);
          const desired = Math.atan2(ty, tx);
          const diff = normalizeAngle(desired - t.angle);
          const rotSpeed = 6.0 * dt;
          t.angle += Math.sign(diff) * Math.min(Math.abs(diff), rotSpeed);
          if (t.cooldown <= 0) {
            projectiles.push({
              x: t.x + 0.5, y: t.y + 0.5,
              vx: Math.cos(t.angle) * 7.0, vy: Math.sin(t.angle) * 7.0,
              speed: 8.0, target: target, life: 1.2
            });
            t.cooldown = t.fireRate;
          }
        } else {
          t.angle += 0.6 * dt;
        }
      } else if (t.type === TOWER.MINE) {
        t.mineTimer += dt;
        if (t.mineTimer >= 2.8) {
          gems += 8 + Math.floor(rng()*8);
          t.mineTimer = 0;
        }
      }
    }
    for (let i=enemies.length-1;i>=0;i--) {
      if (enemies[i].hp <= 0) {
        gems += 8 + Math.floor(rng()*6);
        enemies.splice(i,1);
      }
    }
  }

  function normalizeAngle(a) {
    while (a > Math.PI) a -= Math.PI*2;
    while (a < -Math.PI) a += Math.PI*2;
    return a;
  }

  function updateProjectiles(dt) {
    for (let i=projectiles.length-1;i>=0;i--) {
      const p = projectiles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.target && Math.hypot(p.x - p.target.x, p.y - p.target.y) < 0.6) {
        if(p.target.hp > 0) p.target.hp -= 6;
        projectiles.splice(i,1);
        continue;
      }
      if (p.life <= 0) projectiles.splice(i,1);
    }
  }

    function drawGrid() {
        const TILE_ZOOMED = TILE * camera.zoom;
        const view = {
            x: camera.x,
            y: camera.y,
            w: CANVAS_W,
            h: CANVAS_H
        };

        const startCol = Math.floor(view.x / TILE_ZOOMED);
        const endCol = Math.ceil((view.x + view.w) / TILE_ZOOMED);
        const startRow = Math.floor(view.y / TILE_ZOOMED);
        const endRow = Math.ceil((view.y + view.h) / TILE_ZOOMED);


        for (let y = startRow; y < endRow; y++) {
            for (let x = startCol; x < endCol; x++) {
                if (!inBounds(x,y)) continue;
                const px = x * TILE,
                    py = y * TILE;
                if (fog[y][x]) {
                    ctx.fillStyle = '#0b0b0b';
                    ctx.fillRect(px, py, TILE, TILE);
                } else {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#3a3a3a';
                        ctx.fillRect(px, py, TILE, TILE);
                    } else {
                        ctx.fillStyle = '#bdbdbd';
                        ctx.fillRect(px, py, TILE, TILE);
                        ctx.strokeStyle = '#a6a6a6';
                        ctx.strokeRect(px, py, TILE, TILE);
                    }
                    if (gemNode[y][x]) {
                        ctx.fillStyle = '#8ff';
                        ctx.beginPath();
                        ctx.arc(px + TILE * 0.75, py + TILE * 0.25, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        ctx.fillStyle = '#444';
        ctx.fillRect(base.x * TILE, base.y * TILE, TILE, TILE);
        ctx.fillStyle = '#222';
        ctx.fillRect(base.x * TILE + 6, base.y * TILE + 6, TILE - 12, TILE - 12);
    }


    function drawTowers() {
    for (const t of towers) {
      const cx = t.x*TILE + TILE/2;
      const cy = t.y*TILE + TILE/2;
      if (t.type === TOWER.BASIC) {
        ctx.fillStyle = 'blue';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.28, 0, Math.PI*2); ctx.fill();
        ctx.save();
        ctx.translate(cx,cy);
        ctx.rotate(t.angle);
        ctx.fillStyle = '#0033cc';
        ctx.fillRect(0, -6, TILE*0.45, 12);
        ctx.restore();
      } else if (t.type === TOWER.LIGHTER) {
        ctx.fillStyle = 'gold';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.3, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,230,100,0.28)';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*2.6, 0, Math.PI*2); ctx.stroke();
      } else if (t.type === TOWER.MINE) {
        ctx.fillStyle = 'green';
        ctx.beginPath(); ctx.arc(cx,cy, TILE*0.26, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0a0';
        ctx.fillRect(cx-6, cy+4, 12, 6);
      }
    }
  }

  function drawEnemies() {
    for (const e of enemies) {
      const cx = e.x * TILE;
      const cy = e.y * TILE;
      ctx.fillStyle = 'crimson';
      ctx.fillRect(cx-10, cy-10, 20, 20);
      ctx.fillStyle = '#222';
      ctx.fillRect(cx-12, cy-16, 24, 4);
      ctx.fillStyle = '#0f0';
      const hpFrac = Math.max(0, e.hp) / (12 + Math.floor(rng()*8));
      ctx.fillRect(cx-12, cy-16, 24 * Math.min(1, hpFrac), 4);
    }
  }

  function drawProjectiles() {
    ctx.fillStyle = 'white';
    for (const p of projectiles) {
      ctx.beginPath();
      ctx.arc(p.x * TILE, p.y * TILE, 4, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawHUD() {
    const hud = document.getElementById('hud');
    hud.innerHTML = `Seed: <b>${GAME_SEED}</b> &nbsp; Gems: <b>${gems}</b> &nbsp; Lives: <b>${lives}</b> &nbsp; Selected: <b>${selectedTower}</b> &nbsp; Cost: ${COST[selectedTower] || '-'}`;
  }

    function screenToWorld(x, y) {
        const worldX = (x + camera.x) / camera.zoom;
        const worldY = (y + camera.y) / camera.zoom;
        return {
            x: worldX,
            y: worldY
        };
    }


    canvas.addEventListener('click', (ev) => {
        const rect = canvas.getBoundingClientRect();
        const mx = ev.clientX - rect.left;
        const my = ev.clientY - rect.top;

        const worldCoords = screenToWorld(mx, my);

        const gx = Math.floor(worldCoords.x / TILE);
        const gy = Math.floor(worldCoords.y / TILE);
        placeTower(gx, gy, selectedTower);
    });

  document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === '1') selectedTower = TOWER.BASIC;
    else if (e.key === '2') selectedTower = TOWER.LIGHTER;
    else if (e.key === '3') selectedTower = TOWER.MINE;
    else if (e.key.toLowerCase() === 'r') {
      const newSeed = Math.floor(Math.random()*0x7fffffff);
      setSeed(newSeed);
    }
  });

    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });

  let lastFrameTime = performance.now();
    function gameLoop(now) {
        const dt = Math.min(0.1, (now - lastFrameTime) / 1000);
        lastFrameTime = now;

        updateCamera(dt);

        lastSpawn += dt * 1000;
        if (lastSpawn >= spawnIntervalMs) {
            spawnEnemy();
            lastSpawn = 0;
        }

        updateEnemies(dt);
        updateTowers(dt);
        updateProjectiles(dt);

        ctx.save();
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
        ctx.translate(-camera.x, -camera.y);
        ctx.scale(camera.zoom, camera.zoom);


        const TILE_ZOOMED = TILE * camera.zoom;
        const view = {
            x: camera.x,
            y: camera.y,
            w: CANVAS_W,
            h: CANVAS_H
        };

        const startCol = Math.floor(view.x / TILE_ZOOMED);
        const endCol = Math.ceil((view.x + view.w) / TILE_ZOOMED);
        const startRow = Math.floor(view.y / TILE_ZOOMED);
        const endRow = Math.ceil((view.y + view.h) / TILE_ZOOMED);

        if (startCol < 2) expandWorld(0, 0, 0, 10);
        if (endCol > COLS - 2) expandWorld(0, 10, 0, 0);
        if (startRow < 2) expandWorld(10, 0, 0, 0);
        if (endRow > ROWS - 2) expandWorld(0, 0, 10, 0);


        drawGrid();
        drawTowers();
        drawEnemies();
        drawProjectiles();

        ctx.restore();

        drawHUD();

        if (lives <= 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
            ctx.fillStyle = 'white';
            ctx.font = '36px sans-serif';
            ctx.fillText('Game Over', CANVAS_W / 2 - 90, CANVAS_H / 2);
        } else {
            requestAnimationFrame(gameLoop);
        }
    }


    function updateCamera(dt) {
        if (keys['w']) camera.y -= camera.speed * dt / camera.zoom;
        if (keys['s']) camera.y += camera.speed * dt / camera.zoom;
        if (keys['a']) camera.x -= camera.speed * dt / camera.zoom;
        if (keys['d']) camera.x += camera.speed * dt / camera.zoom;

        if (keys['q']) camera.zoom *= (1 + dt);
        if (keys['e']) camera.zoom *= (1 - dt);

        camera.zoom = Math.max(0.2, Math.min(camera.zoom, 5));
    }


  function initGame(keepSeed=false) {
    if (!keepSeed) {
      GAME_SEED = parseSeed();
      rng = mulberry32(GAME_SEED);
    } else {
      rng = mulberry32(GAME_SEED);
    }
    gems = 120; lives = 10; towers = []; enemies = []; projectiles = [];
    initGrid(ROWS, COLS);
    generateInitialNeighborhood();
    placeTower(base.x, base.y, TOWER.LIGHTER);
    lastFrameTime = performance.now();
    lastSpawn = 0;

    camera.x = (base.x * TILE - CANVAS_W / 2 / camera.zoom);
    camera.y = (base.y * TILE - CANVAS_H / 2 / camera.zoom);
  }

  window.__td = { setSeed, getSeed: () => GAME_SEED, rng, maze, fog, gemNode, towers, enemies };

  initGame(false);
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
